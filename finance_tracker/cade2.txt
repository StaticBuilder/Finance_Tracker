as you can see from below the budget table is linked to the period table , so how can i structure it so that it uses the budgetId to get the periodId for its respective table extract the start and end date and when the user enters the date of the expense it ensures the date is within that time period if not it will inform the user in a message pop up that the expense must be between so and so date

this is the AddExpense.jsx file
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { db } from "../../../../../../utils/dbConfig"; 
import { Budgets, Expenses } from "../../../../../../utils/schema";
import { Loader } from "lucide-react";
import moment from "moment";
import React, { useState, useEffect } from "react";
import { toast } from "sonner";

function AddExpense({ budgetId, user, refreshData }) {
  const [name, setName] = useState("");
  const [amount, setAmount] = useState("");
  const [date, setDate] = useState("");
  const [loading, setLoading] = useState(false);

  // Set default date to today when component mounts
  useEffect(() => {
    const today = new Date();
    // Format date as YYYY-MM-DD for input type="date"
    const formattedDate = today.toISOString().split('T')[0];
    setDate(formattedDate);
  }, []);

  /**
   * Used to Add New Expense
   */
  const addNewExpense = async () => {
    setLoading(true);
    try {
      // Format the date for database storage
      const formattedDate = moment(date).format("DD/MM/YYYY");
      
      const result = await db
        .insert(Expenses)
        .values({
          name: name,
          amount: amount,
          budgetId: budgetId,
          createdAt: formattedDate,
        })
        .returning({ insertedId: Budgets.id });

      if (result) {
        refreshData();
        toast.success("New Expense Added!");
        // Reset form
        setAmount("");
        setName("");
        // Reset date to today
        const today = new Date().toISOString().split('T')[0];
        setDate(today);
      }
    } catch (error) {
      console.error("Error adding expense:", error);
      toast.error("Failed to add expense");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="border p-5 rounded-2xl">
      <h2 className="font-bold text-lg">Add Expense</h2>
      <div className="mt-2">
        <h2 className="text-black font-medium my-1">Expense Name</h2>
        <Input
          placeholder="e.g. Bedroom Decor"
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
      </div>
      <div className="mt-2">
        <h2 className="text-black font-medium my-1">Expense Amount</h2>
        <Input
          type="number"
          placeholder="e.g. 1000"
          value={amount}
          onChange={(e) => setAmount(e.target.value)}
        />
      </div>
      <div className="mt-2">
        <h2 className="text-black font-medium my-1">Date</h2>
        <Input
          type="date"
          value={date}
          onChange={(e) => setDate(e.target.value)}
        />
      </div>
      <Button
        disabled={!(name && amount && date) || loading}
        onClick={() => addNewExpense()}
        className="mt-3 w-full rounded-full"
      >
        {loading ? <Loader className="animate-spin" /> : "Add New Expense"}
      </Button>
    </div>
  );
}

export default AddExpense;

this is the database schema
import {
  integer,
  numeric,
  pgTable,
  serial,
  varchar,
} from "drizzle-orm/pg-core";

export const Periods = pgTable("periods", {
  id: serial("id").primaryKey(),             // Unique identifier for the period
  name: varchar("name").notNull(),           // Name of the period
  type: varchar("type").notNull(),           // Time frame type (weekly, monthly, yearly)
  startDate: varchar("startDate").notNull(), // Start date as a string
  endDate: varchar("endDate").notNull(),     // End date as a string
  createdBy: varchar("createdBy").notNull(), // The user who created the period
  createdAt: varchar("createdAt").default("NOW()"), // Use "NOW()" as a default timestamp string
});

export const PeriodSelected = pgTable("period_selected", {
  id: serial("id").primaryKey(),// Unique identifier for the selection
  createdBy: varchar("createdBy").notNull(),
  periodId: integer("period_id").references(() => Periods.id), // Links to the selected period
  createdAt: varchar("created_at").default("NOW()"),           // Timestamp of when the selection was made
  updatedAt: varchar("updated_at").default("NOW()") // Timestamp of when the selection was last updated
});

export const Budgets = pgTable("budgets", {
  id: serial("id").primaryKey(),
  name: varchar("name").notNull(),
  amount: varchar("amount").notNull(),
  icon: varchar("icon"),
  createdBy: varchar("createdBy").notNull(),
  periodId: integer("periodId").references(() => Periods.id), // Links to a period
});

export const Incomes = pgTable("incomes", {
  id: serial("id").primaryKey(),
  name: varchar("name").notNull(),
  amount: varchar("amount").notNull(),
  icon: varchar("icon"),
  createdBy: varchar("createdBy").notNull(),
  periodId: integer("periodId").references(() => Periods.id), // Links to a period
});

export const Expenses = pgTable("expenses", {
  id: serial("id").primaryKey(),
  name: varchar("name").notNull(),
  amount: numeric("amount").notNull().default(0),
  budgetId: integer("budgetId").references(() => Budgets.id),
  createdAt: varchar("createdAt").notNull(),
});
